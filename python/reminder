# Imutables -> numbers, strings and tuples
# Mutables -> list, dictionaries and sets

# Show attributes.
dir('some string')

# Help.
help(''.replace)

# Character code conversion:
ord('A')
chr(65)

# Unicode
'\xc4'  #A
u'\xc4' #A

# byte
b'xc4'  #xc4

# Hex to bin:
bin(0xff)

# Check if is instance of:
b=2.1
isinstance(b, float)
isinstance(b, (int, float))

# Check if object has some attribute:
hasattr(s, '__iter__')

# Call a method:
getattr(s, 'split')()

# Add a method:
setattr

# Check if two variables refer to the same object:
a=1
b=a
a is b

# Negative stride:
s='123456789'
s[::-1]     #'987654321'
s[::-2]     #'97531'

# Convert to as-code string
repr(3)

# Replace the first ocurrency only:
'ab2ab3ab4ab'.replace('ab', '--', 1)    # '--2ab3ab4ab'

# Regular expression:
re.match('a', 'cat')    # False
re.match('a', 'acat')   # <re.Match object; span=(0, 1), match='a'>
re.search('a', 'cat')   # <re.Match object; span=(1, 2), match='a'>
re.split('[ab]', 'carbs')   # ['c', 'r', 's']
re.sub('[0-9]', '---', 'e2k3k4j5k6sdlk8jfs0jk') # 'e---k---k---j---k---sdlk---jfs---jk'

l, n = zip(('a', 1), ('b', 2), ('c', 3))
l   # ('a', 'b', 'c')
n   $ (1, 2, 3)

Dictionary-Based Formatting Expressions
>>> # Template with substitution targets
>>> reply = """
Greetings...
Hello %(name)s!
Your age is %(age)s
"""
>>> values = {'name': 'Bob', 'age': 40} # Build up values to substitute
>>> print(reply % values) # Perform substitutions
Greetings...
Hello Bob!
Your age is 40

# Show all defined vars in the current context:
vars()

>>> template = '%s, %s and %s' # Same via expression
>>> template % ('spam', 'ham', 'eggs')
'spam, ham and eggs'
>>> template = '%(motto)s, %(pork)s and %(food)s'
>>> template % dict(motto='spam', pork='ham', food='eggs')
'spam, ham and eggs'

# Another example:
'My {1[kind]} runs {0.platform}'.format(sys, {'kind': 'laptop'})

>>> somelist = list('SPAM')
>>> somelist
['S', 'P', 'A', 'M']
>>> 'first={0[0]}, third={0[2]}'.format(somelist)
'first=S, third=A'
>>> 'first={0}, last={1}'.format(somelist[0], somelist[-1]) # [-1] fails in fmt
'first=S, last=M'
>>> parts = somelist[0], somelist[-1], somelist[1:3] # [1:3] fails in fmt
>>> 'first={0}, last={1}, middle={2}'.format(*parts) # Or '{}' in 2.7/3.1+
"first=S, last=M, middle=['P', 'A']"

>>> '{0:10} = {1:10}'.format('spam', 123.4567) # In Python 3.3
'spam = 123.4567'
>>> '{0:>10} = {1:<10}'.format('spam', 123.4567)
' spam = 123.4567

>>> '{0:e}, {1:.3e}, {2:g}'.format(3.14159, 3.14159, 3.14159)
'3.141590e+00, 3.142e+00, 3.14159'
>>> '{0:f}, {1:.2f}, {2:06.2f}'.format(3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 003.14'

>>> '{0:X}, {1:o}, {2:b}'.format(255, 255, 255) # Hex, octal, binary
'FF, 377, 11111111'
>>> bin(255), int('11111111', 2), 0b11111111 # Other to/from binary
('0b11111111', 255, 255)
>>> hex(255), int('FF', 16), 0xFF # Other to/from hex
('0xff', 255, 255)
>>> oct(255), int('377', 8), 0o377 # Other to/from octal, in 3.X
('0o377', 255, 255) # 2.X prints and accepts 0377


def magic(*args, **kwargs):
    print("unnamed args:", args)
    print("keyword args:", kwargs)
magic(1, 2, key="word", key2="word2")
# prints
# unnamed args: (1, 2)
# keyword args: {'key': 'word', 'key2': 'word2'}


def other_way_magic(x, y, z):
    return x + y + z
x_y_list = [1, 2]
z_dict = {"z": 3}
assert other_way_magic(*x_y_list, **z_dict) == 6, "1 + 2 + 3 should be 6"

# Study this libs:
mypy
from typing import Union

from typing import List # note capital L
def total(xs: List[float]) -> float:
    return sum(total)

from typing import Optional
values: List[int] = []
best_so_far: Optional[float] = None # allowed to be either a float or None

# the type annotations in this snippet are all unnecessary
from typing import Dict, Iterable, Tuple
# keys are strings, values are ints
counts: Dict[str, int] = {'data': 1, 'science': 2}
# lists and generators are both iterable
if lazy:
    evens: Iterable[int] = (x for x in range(10) if x % 2 == 0)
else:
    evens = [0, 2, 4, 6, 8]
# tuples specify a type for each element
triple: Tuple[int, float, int] = (10, 2.3, 5)


from typing import Callable
# The type hint says that repeater is a function that takes
# two arguments, a string and an int, and returns a string.
def twice(repeater: Callable[[str, int], str], s: str) -> str:
    return repeater(s, 2)
def comma_repeater(s: str, n: int) -> str:
    n_copies = [s for _ in range(n)]
    return ', '.join(n_copies)
assert twice(comma_repeater, "type hints") == "type hints, type hints"


https://ipython.readthedocs.io/en/stable/interactive/index.html
https://mypy.readthedocs.io/en/stable/

In [32]: seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
In [33]: for a, b, c in seq:
....: print(f'a={a}, b={b}, c={c}')
a=1, b=2, c=3
a=4, b=5, c=6
a=7, b=8, c=9


In [34]: values = 1, 2, 3, 4, 5
In [35]: a, b, *rest = values
In [36]: a
Out[36]: 1
In [37]: b
Out[37]: 2
In [38]: rest
Out[38]: [3, 4, 5]


In [40]: a = (1, 2, 2, 2, 3, 4, 2)
In [41]: a.count(2)
Out[41]: 4


