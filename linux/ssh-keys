$ pacman -S openssh
# Install package to use ssh-keys tools.

# SSH keys are always generated in pairs with one known as the private key and the other as the public key. 
  The private key is known only to you and it should be safely guarded. 
  By contrast, the public key can be shared freely with any SSH server to which you wish to connect.

# If an SSH server has your public key on file and sees you requesting a connection, it uses your public key to construct and send you a challenge. 
  This challenge is an encrypted message and it must be met with the appropriate response before the server will grant you access. 
  What makes this coded message particularly secure is that it can only be understood by the private key holder. 
  While the public key can be used to encrypt the message, it cannot be used to decrypt that very same message. 
  Only you, the holder of the private key, will be able to correctly understand the challenge and produce the proper response.

# This challenge-response phase happens behind the scenes and is invisible to the user. 
  As long as you hold the private key, which is typically stored in the ~/.ssh/ directory, your SSH client should be able to reply with the appropriate response to the server.

# A private key is a guarded secret and as such it is advisable to store it on disk in an encrypted form.
  When the encrypted private key is required, a passphrase must first be entered in order to decrypt it. 
  While this might superficially appear as though you are providing a login password to the SSH server, the passphrase is only used to decrypt the private key on the local system. 
  The passphrase is not transmitted over the network.

$ ssh-keygen
# An SSH key pair can be generated by running the ssh-keygen command, defaulting to 2048-bit RSA (and SHA256) which the ssh-keygen(1) man page says is "generally considered sufficient" and should be compatible with virtually all clients and servers.

$ ssh-keygen -t rsa -b 4096 -C "your_mail@example.com"
# Creates a new ssh key with 4096-bit RSA, using the provided email as a label (optional comment put in the public key).

$ ssh-keygen -f ~/.ssh/id_rsa -p
# The passphrase for the private RSA key.

~/.ssh
# Default place where ssh-key pair is save.

$ eval "$(ssh-agent -s)"
# Start the ssh-agent in the background.

$ ssh-add ~/.ssh/id_rsa
# Add your SSH private key to the ssh-agent.

$ xclip -sel clip < ~/.ssh/id_rsa.pub
# Copies the contents of the id_rsa.pub file to your clipboard.
# Paste the content on github settings/SSH and GPG keys/New SSH Key.

# Start ssh-agent with systemd user.
~/.config/systemd/user/ssh-agent.service
  [Unit]
  Description=SSH key agent
  
  [Service]
  Type=forking
  Environment=SSH_AUTH_SOCK=%t/ssh-agent.socket
  ExecStart=/usr/bin/ssh-agent -a $SSH_AUTH_SOCK
  
  [Install]
  WantedBy=multi-user.target
# Add to your shell's startup file, for example .bash_profile for Bash, zshrc for zsh.
export SSH_AUTH_SOCK="$XDG_RUNTIME_DIR/ssh-agent.socket"
# Enable the service.
$ systemctl --user enable ssh-agent.service

# Remove ssh key when REMOTE HOST IDENTIFICATION HAS CHANGED.
$ ssh-keygen -R vps10092.publiccloud.com.br

# Copy public key to remote server:
$ ssh-copy-id vps10092.publiccloud.com.br
# If user differ on remote machine:
$ ssh-copy-id douglasmg7@vps10092.publiccloud.com.br

# Test connection. 
$ ssh vps10092.publiccloud.com.br



# Start ssh-agent.
# To make use of env variables generated by ssh-agent, run the command through the eval command.
eval `ssh-agent`

# Check if agent is running.
echo $SSH_AUTH_SOCK
echo $SSH_AGENT_PID

# Add identities to the agent.
ssh-add ~/.ssh/id_ed25519
