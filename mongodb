mongo
start mongo shell
looks for a database server listening on port 27017 on the localhost
for diferente host and port use the options --port and --host

db
display the current db

show dbs
display the list of databases

use mydb
switch to a new database named mydb

help
method.help()
get mongo help

j = {l:3}
db.testDb.insert(j)
create a document j and insert into testDb collection

db.testDb.save({a:1})
saves a document in the collection

db.testDb.update(query, {$set: data});
updates items that match query in with data object values

db.testDb.remove(query)
removes all items that match query criteria

printjson(document)
prints the variable document

show collections
list the collections

db.testDb.find()
return a iterator

db.testDb.find().limit(3)
return a iterator with limit of 3

db.testDb.findOne()
return a document

it
to iterate over the next set of result

.mongorc.js
the mongo shell loads and parses the .mongorc.js file on startup so your function is available every time you start a session

mongoimport --db blog --collection users --file ./db/users.json --jsonArray
insert data into database from a json file

db.potions.remove({'name': 'Love'});
remove all documents that match

db.potions.update({'name': 'Love'}, {'$set': {'price': 3.99}});
update just the first match

db.potions.update({'name': 'Love'}, {'price': 3.99});
will have just the price property and id

db.potions.update({'name': 'Love'}, {'$set': {'price': 3.99}}, {'multi', true});
update all match documents


db.potions.update({'portion': 'Shrinking'}, {'$inc': {'count': 2}});
update count += 2

db.potions.update({'portion': 'Shrinking'}, {'$inc': {'count': 1}}, {'upsert', true});
create documento if not found

db.potions.update(
	{},
	{'$unset': {'color': ''}},
	{'multi': true}
)
remove color field from all documents

db.potions.update(
	{},
	{'$rename': {'score': 'grade'}},
	{'multi': true}
)
rename field score to grade on all documents

db.potions.update(
	{'name', 'Shrinking'},
	{'$set': {'ingredients.1': 42}},
)
update the second value of array ingredients

db.potions.update(
	{'ingredients', 'secret'},
	{'$set': {'ingredients.$': 42}},
	{'multi': true}
)
$ define the element secret on array ingredients

db.potions.update(
	{'name', 'Shrinking'},
	{'$pop': {'categories': 1}},
remove the last element from array 'categories' (-1 for the first)

db.potions.update(
	{'name', 'Shrinking'},
	{'$push': {'categories': 'budget'}},
add budget to the end of array categories

db.potions.update(
	{'name', 'Shrinking'},
	{'$addToSet': {'categories': 'budget'}},
only add budget to the end of array categories if not exist yet

db.potions.update(
	{'name', 'Shrinking'},
	{'$pull': {'categories': 'budget'}},
remove any budget instance from array categories

$gt, $gte, $ne, $lt, $lte
comparison query operators

db.potions.find({'price': {'$gt':10, '$lt': 20}});

db.portions.find({'sizes': {'$elemMatch': {'$gt':8, '$lt': 16}}});
sizes = [5, 8 11]

db.portions.find(grade: {$gte: 80}, {vendor: true, name: true});
db.wands.find({}, {'name':true});
projection, return only the fields vendor and name (document_id is always returned)

db.protions.find(grade: {$gte: 80}, {vendor: false, price: false});
exclude specific fields

db.protions.find().count()
number of itens on the cursor

db.portions.find().sort({'price: 1'});
sort

db.portions.find().limit(3);
limit the number of returned itens

db.portions.find().skip(3).limit(3);
skip the first 3 and get the next 3

{
	name: 'invisibilty',
	vendor_id: 'portions_sa' 
}
reference to another document

embedding
documents accessed through parent
single query
atomic writes

reference
documents exist independently
require 2 queries
doesn't support multi-document writes

data size over 100
consider use reference

db.portions.aggregate(
	[{$group: {_id: '$vendor_id'}}]
)
aggregation framework

db.portions.aggregate([
	{$group: 
		{
			_id: '$vendor_id', 
			'total': {'$sum': 1},
			'grade_total': {'$sum': '$grade'}
		}
	}
]);
$x: $y - x is a operator, y is a filed pattern
{'_id': "Keetcoocked", 'total': 2, 'grade_total': 400},
{'_id': "Brewers", 'total': 1, 'grade_total': 340},
{'_id': "Leprechaun Inc", 'total': 1, 'grade_total': 92}

db.portions.aggregate([
	{$group: 
		{
			_id: '$vendor_id', 
			'avg-grade': {'$avg': '$grade'}
		}
	}
]);
averaging grade per vendor

db.portions.aggregate{[
	{'$match': {'ingredients': 'unicorn'}},
	{'$group': 
		{
			'_id': $vendor_id,
			'portion_count': {'$sum': 1}
		}
	}

]};
pipeline

db.portions.aggregate{[
	{'$match': {'price': {'$lt': 15}}},
	{'$project': {'_id': false, 'vendor_id: true': 'grade': true}}.
	{'$group': {'_id': '$vender_id', 'avg_grade': {'$avg': '$grade'}}},
	{'$sort': {'avg_grade': -1}},
	{'$limit': 3}
]};
more complex pipeline